## 1\. [개념] 자바스크립트 함수의 매개변수, 리턴값

  * **매개변수 (Parameter):** 함수를 호출할 때 함수에게 "재료"를 전달하기 위한 통로입니다. 함수 정의 시 괄호 `()` 안에 선언하는 변수이며, "입력값"이라고 생각할 수 있습니다.
  * **리턴값 (Return Value):** 함수가 자신의 작업을 모두 마친 후, 호출한 곳으로 "결과"를 돌려주는 값입니다. `return` 키워드를 사용하며, "출력값"이라고 생각할 수 있습니다.

### 기본 예제

```javascript
// 'a'와 'b'는 매개변수(parameter)입니다.
function add(a, b) {
  let result = a + b;
  // 'result' 값을 호출한 곳으로 돌려줍니다 (return).
  return result;
}

// 10과 5가 'a'와 'b' 매개변수로 전달됩니다.
// 'sum' 변수는 함수의 리턴값(15)을 받습니다.
let sum = add(10, 5);

console.log(sum); // 15
```

-----

## 2\. [실습] ☕ 카페 키오스크 만들기

> "손님, 얼마 넣으시겠어요?"
>
> `getCoffee`라는 이름의 함수를 만들어주세요.
>
> 1.  이 함수는 손님이 낸 돈(`money`)을 \*\*매개변수(parameter)\*\*로 받습니다.
> 2.  함수 안에서, 만약 `money`가 4000원 이상이면 `"아메리카노"`를 \*\*리턴(return)\*\*합니다.
> 3.  `money`가 4000원 미만이면 `"물"`을 \*\*리턴(return)\*\*합니다.
>
> **미션:**
>
>   * `getCoffee(5000)`을 호출한 결과를 출력해 보세요.
>   * `getCoffee(3000)`을 호출한 결과를 출력해 보세요.

### [실습 풀이]

```javascript
function getCoffee(money) {
  if (money >= 4000) {
    return "아메리카노";
  } else {
    return "물";
  }
}

// 미션 1: 5000원 (4000원 이상)
console.log(getCoffee(5000)); // "아메리카노"

// 미션 2: 3000원 (4000원 미만)
console.log(getCoffee(3000)); // "물"
```

-----

## 3\. [개념] 자바스크립트의 내장함수 isNaN()

`isNaN()`은 \*\*"Is Not a Number?"\*\*의 줄임말입니다.

이 함수는 **주어진 값이 숫자가 아닌지(NaN) 검사**합니다. 숫자 변환이 불가능한 값을 식별하는 데 주로 사용됩니다.

  * 값이 숫자가 아니거나 숫자로 변환될 수 없으면 `true`를 반환합니다.
      * `isNaN("스무살")`  -\> `true`
      * `isNaN(undefined)` -\> `true`
  * 값이 숫자이거나 숫자로 변환될 수 있으면 `false`를 반환합니다.
      * `isNaN(19)`       -\> `false`
      * `isNaN("19")`     -\> `false` ("19"는 숫자 19로 변환 가능)

**주요 활용 용도:** 사용자 입력값이 유효한 숫자인지 확인할 때 매우 유용합니다.

-----

## 4\. [실습] 🛡️ 게임 접속기 만들기

> "나이를 숫자로 입력하세요\!"
>
> 1.  사용자로부터 나이를 입력받았다고 가정하고, 변수를 두 개 만듭니다.
>     `let input1 = "19";`
>     `let input2 = "스무살";`
>
> 2.  `checkAge`라는 이름의 함수를 만드세요. 이 함수는 사용자 입력(`userInput`)을 매개변수로 받습니다.
>
> 3.  함수 안에서, `userInput` 값이 `isNaN()` 검사를 통과하지 못하면 (즉, **숫자가 맞다면**) `"접속을 허용합니다."`라고 출력합니다.
>
> 4.  만약 `isNaN()` 검사 결과가 `true`라면 (즉, **숫자가 아니라면**) `"경고: 나이는 숫자로만 입력하세요!"`라고 출력합니다.
>
> **미션:**
>
>   * `checkAge(input1)`을 호출해 보세요.
>   * `checkAge(input2)`를 호출해 보세요.

### [실습 풀이]

```javascript
let input1 = "19";
let input2 = "스무살";

function checkAge(userInput) {
  // isNaN(userInput)가 false라는 것은 "숫자가 맞다"는 의미
  if (isNaN(userInput) === false) {
    console.log("접속을 허용합니다.");
  } else {
    // isNaN(userInput)가 true라는 것은 "숫자가 아니다"라는 의미
    console.log("경고: 나이는 숫자로만 입력하세요!");
  }
}

// 미션 1: input1 ("19")
checkAge(input1); // 접속을 허용합니다. (isNaN("19") -> false)

// 미션 2: input2 ("스무살")
checkAge(input2); // 경고: 나이는 숫자로만 입력하세요! (isNaN("스무살") -> true)
```

-----

## 5\. [개념] parseInt(), parseFloat()의 기본 예제와 차이점

`parseInt()`와 `parseFloat()`는 둘 다 문자열을 숫자로 변환하는 함수입니다.

  * **`parseInt(string)` (정수 변환):**

      * 문자열을 \*\*정수(Integer)\*\*로 변환합니다.
      * 숫자로 시작하는 부분까지만 읽고, 소수점이나 그 뒤의 문자는 버립니다.
      * `parseInt("10.7px");` // `10` (소수점 .과 그 뒤는 버림)
      * `parseInt(" 120 원");` // `120` (앞 공백 무시, '원' 앞에서 멈춤)
      * `parseInt("A100");`  // `NaN` (숫자가 아닌 문자로 시작)

  * **`parseFloat(string)` (실수 변환):**

      * 문자열을 \*\*실수(Float, 소수점 포함)\*\*로 변환합니다.
      * 첫 번째 소수점(.)까지는 숫자로 인식하여 포함합니다.
      * `parseFloat("10.7px");` // `10.7` (소수점 .을 인식함)
      * `parseFloat(" 120.5 원");` // `120.5`
      * `parseFloat("A100");`  // `NaN` (숫자가 아닌 문자로 시작)

### 차이점

가장 큰 차이는 **소수점 처리 여부**입니다. `parseInt()`는 정수만 반환(소수점 버림), `parseFloat()`는 소수점까지 포함하여 반환합니다.

-----

## 6\. [실습] 📏 재료 손질하기

> 레시피북에 적힌 재료의 양이 지저분합니다.
>
> `let ingredient1 = "밀가루 300.7g";`
> `let ingredient2 = "설탕 150.2g";`

### [실습 풀이]

> **⚠️ 중요:** `parseInt()`와 `parseFloat()`는 문자열이 **숫자(또는 공백)로 시작**해야 합니다.
>
> 원본 예제(`"밀가루 300.7g"`)처럼 문자로 시작하면 `NaN`을 반환합니다. 아마도 의도하신 예제는 `"300.7g 밀가루"`와 같이 숫자가 앞에 오는 경우일 것입니다.
>
> 아래 풀이는 **숫자가 앞에 온다고 수정한 예제**입니다.

```javascript
// 실습이 가능하도록 예제 문자열을 수정 (숫자가 앞으로 오도록)
let ingredient1 = "300.7g 밀가루";
let ingredient2 = "150.2g 설탕";

// 1. ingredient1에서 정수(integer)로만 추출
// "300.7g 밀가루" -> 300 (소수점 .에서 멈춤)
let flourAmount = parseInt(ingredient1);
console.log("밀가루(정수):", flourAmount); // 밀가루(정수): 300

// 2. ingredient2에서 소수점까지 포함하여 추출
// "150.2g 설탕" -> 150.2 (문자 g 앞에서 멈춤)
let sugarAmount = parseFloat(ingredient2);
console.log("설탕(소수):", sugarAmount); // 설탕(소수): 150.2

// --- 만약 원본 예제를 그대로 사용한다면 ---
let original1 = "밀가루 300.7g";
console.log("원본 예제 결과:", parseInt(original1)); // 원본 예제 결과: NaN
```

-----

## 7\. [개념] Number()와 parseInt()의 차이점

`Number()`와 `parseInt()`는 둘 다 문자열을 숫자로 바꾸려 하지만, 변환 방식에 큰 차이가 있습니다.

  * **`parseInt()` (관대한 변환):**

      * 문자열의 **시작**부터 읽습니다.
      * 숫자로 인식되는 부분을 최대한 읽고, **숫자가 아닌 문자를 만나면 즉시 중단**합니다.
      * 항상 **정수**만 반환합니다.
      * 예: `parseInt("5000원")` -\> `5000` ('원' 앞에서 멈춤)
      * 예: `parseInt(" 7000 원 ")` -\> `7000` (앞 공백 무시, ' 원' 앞에서 멈춤)

  * **`Number()` (엄격한 변환):**

      * 문자열 **전체**가 완벽한 숫자여야만 변환에 성공합니다.
      * 앞뒤 공백은 무시하지만, 숫자 사이에 공백이나 \*\*숫자 외의 문자(예: 원, px)가 하나라도 있으면 `NaN`\*\*을 반환합니다.
      * 소수점을 포함할 수 있습니다.
      * 예: `Number("5000원")` -\> `NaN` ('원' 때문에 실패)
      * 예: `Number(" 7000 원 ")` -\> `NaN` (' 원' 때문에 실패)
      * 예: `Number(" 5000 ")` -\> `5000` (이 경우는 성공)

-----

## 8\. [실습] 🏷️ 가격표 읽기 대결

> 마트에 두 개의 가격표가 붙어있습니다.
>
> `let priceTag1 = "5000원";`
> `let priceTag2 = " 7000 원 ";` // (앞뒤 공백 주의)

### [실습 풀이]

```javascript
let priceTag1 = "5000원";
let priceTag2 = " 7000 원 ";

// 1. priceTag1 ("5000원")
console.log("parseInt(priceTag1):", parseInt(priceTag1)); // 5000
console.log("Number(priceTag1):", Number(priceTag1));     // NaN

// 2. priceTag2 (" 7000 원 ")
console.log("parseInt(priceTag2):", parseInt(priceTag2)); // 7000
console.log("Number(priceTag2):", Number(priceTag2));     // NaN

// 3. Number()가 NaN이 나오는 이유
// Number(priceTag1)가 NaN인 이유:
//   "5000원" 문자열 전체를 변환하려다 '원' 글자 때문에 실패.
//
// Number(priceTag2)가 NaN인 이유:
//   " 7000 원 "은 앞뒤 공백은 제거하지만( "7000 원" ),
//   숫자 7000 뒤의 공백과 '원' 글자 때문에 문자열 전체가 숫자가 아님.
```

-----

## 9\. [개념] 자바스크립의 기본 객체 (Object)

자바스크립트 객체(Object)는 \*\*관련된 데이터(속성)와 행동(메서드)을 하나로 묶어놓은 "데이터 상자"\*\*입니다. `{}` (중괄호)를 사용하여 만듭니다.

  * **속성 (Property):** 객체가 가진 데이터 조각입니다. `이름: 값` (key: value)의 쌍으로 표현합니다. (예: `name: "홍길동"`)
  * **메서드 (Method):** 객체가 할 수 있는 행동(동작)입니다. 속성값으로 `function()` (함수)이 들어간 것을 말합니다.

### 기본 예제

```javascript
// 'person'이라는 이름의 객체 생성
let person = {
  // 1. 속성 (Properties)
  name: "홍길동",
  age: 30,
  isStudent: false,

  // 2. 메서드 (Methods)
  sayHello: function() {
    // 'this.name'은 "이 객체(person)의 name 속성"이라는 뜻
    console.log("안녕하세요, 제 이름은 " + this.name + "입니다.");
  },
  
  addAge: function() {
    this.age++;
    console.log("나이를 1살 먹었습니다. 현재 나이: " + this.age);
  }
};

// 객체 사용하기
console.log(person.name); // 속성 접근 (출력: 홍길동)
person.sayHello();      // 메서드 호출 (출력: 안녕하세요, 제 이름은 홍길동입니다.)
person.addAge();        // 메서드 호출 (출력: 나이를 1살 먹었습니다. 현재 나이: 31)
console.log(person.age); // 속성 접근 (출력: 31)
```

-----

## 10\. [실습] 🦸‍♂️ 나만의 히어로 만들기

> 1.  `hero`라는 이름의 객체(Object)를 만들어주세요.
> 2.  `hero` 객체는 속성(property)으로 `name: "아이언맨"`과 `level: 1`을 가집니다.
> 3.  `hero` 객체는 메서드(method)로 `fly` (호출 시 `"슈우우웅! 날아갑니다!"` 출력)와 `levelUp` (호출 시 `level` 속성 1 증가)을 가집니다.
>
> **미션:** `hero`의 이름을 출력하고, `fly`, `levelUp`을 호출한 뒤 `level`을 확인하세요.

### [실습 풀이]

```javascript
let hero = {
  // 2. 속성 (Properties)
  name: "아이언맨",
  level: 1,

  // 3. 메서드 (Methods)
  fly: function() {
    console.log("슈우우웅! 날아갑니다!");
  },
  levelUp: function() {
    // 'this'는 'hero' 객체 자신을 가리킵니다.
    this.level = this.level + 1; // 또는 this.level++
    console.log("레벨 업! 현재 레벨: " + this.level);
  }
};

// --- 미션 수행 ---

// 1. hero의 이름을 출력
console.log(hero.name); // 아이언맨

// 2. hero.fly() 메서드 호출
hero.fly(); // 슈우우웅! 날아갑니다!

// 3. hero.levelUp() 메서드 호출
hero.levelUp(); // 레벨 업! 현재 레벨: 2

// 4. hero의 level이 2가 되었는지 확인
console.log(hero.level); // 2
```

-----

## 11\. [개념] JSON이란? (vs 자바스크립트 객체)

\*\*JSON (JavaScript Object Notation)\*\*은 데이터를 주고받기 위해 고안된 \*\*"경량 데이터 교환 형식"\*\*입니다.

쉽게 말해, A컴퓨터(서버)에서 B컴퓨터(브라우저)로 "데이터"를 보낼 때 사용하는 \*\*"표준화된 문자열(String) 포장지"\*\*입니다.

### JSON vs 자바스크립트 객체 (Object)

| 특징 | 자바스크립트 객체 (Object) | JSON (문자열) |
| --- | --- | --- |
| **정의** | 자바스크립트의 **데이터 타입** (메모리에 존재) | 데이터를 표현하는 **문자열(String)** 형식 |
| **용도** | 프로그램 내에서 데이터와 기능을 묶어서 관리 | **데이터 전송** (네트워크, 파일 저장 등) |
| **키(Key)** | 따옴표가 없어도 됨 (예: `name`) | \*\*반드시 큰따옴표("")\*\*로 묶어야 함 (예: `"name"`) |
| **값(Value)** | 함수(메서드), `undefined` 등 모두 가능 | 함수, `undefined` **사용 불가능** (문자열, 숫자, 불리언, 배열, 객체만 가능) |
| **예시** | `let obj = { name: "A" }` | `let json = '{ "name": "A" }'` |

**핵심:** 자바스크립트 객체를 네트워크로 보내거나 파일로 저장할 수 없기 때문에, \*\*JSON이라는 문자열 형식으로 변환(직렬화)\*\*해서 보내고, 받을 때는 다시 \*\*JSON 문자열을 객체로 변환(역직렬화)\*\*해서 사용합니다.

-----

## 12\. [실습] 📦 객체를 택배로 보내기 (JSON 변환)

> 자바스크립트 세상(A컴퓨터)에 살고 있는 `student` 객체가 있습니다. 이 객체를 다른 서버(B컴퓨터)로 '데이터 전송'을 하려고 합니다.
>
> `let student = { name: "김학생", age: 10, isMale: true };`
>
> **미션:** `student` 객체를 **JSON 형식의 문자열**로 변환하여 `jsonData`라는 변수에 저장하고 출력하세요. (힌트: `JSON.stringify()`)

### [실습 풀이]

```javascript
let student = { name: "김학생", age: 10, isMale: true };

// 1. student 객체를 JSON 형식의 문자열로 변환
// JSON.stringify() : 객체 -> JSON 문자열
let jsonData = JSON.stringify(student);

// 2. jsonData 출력
console.log(jsonData);
// 출력 결과: { "name": "김학생", "age": 10, "isMale": true }

// 3. 관찰
// 원본 객체의 키(name, age, isMale)에는 따옴표가 없었지만,
// JSON 문자열로 변환되면서 키에 모두 큰따옴표("")가 붙었습니다.
// 또한, 전체가 하나의 문자열이 되었습니다.
```

-----

## 13\. [개념] javascript 객체형 배열

**객체형 배열**은 \*\*"객체(Object)들을 담고 있는 배열(Array)"\*\*을 의미합니다.

  * **배열 `[]`:** 순서가 있는 목록 (아파트 건물)
  * **객체 `{}`:** 관련된 데이터의 묶음 (아파트 101호, 102호...)

"학생 명단"을 관리할 때, 학생 한 명 한 명의 정보(이름, 나이, 점수)를 `{}` 객체로 만들고, 이 학생 객체들을 `[]` 배열에 차곡차곡 담는 방식입니다.

### 기본 예제

```javascript
// 'students'는 객체형 배열입니다.
let students = [
  // 0번째 요소 (101호)
  { name: "김철수", score: 90 },
  // 1번째 요소 (102호)
  { name: "이영희", score: 85 },
  // 2번째 요소 (103호)
  { name: "박바둑", score: 95 }
];

// 객체형 배열 사용하기

// 1. 특정 학생의 정보 접근
// students[1] -> { name: "이영희", score: 85 }
console.log(students[1].name); // "이영희"

// 2. 배열 순회(Loop)
for (let i = 0; i < students.length; i++) {
  // students[i]는 루프마다 각 학생 객체가 됩니다.
  console.log(students[i].name + " 학생의 점수는 " + students[i].score + "점");
}
```

-----

## 14\. [실습] 🛒 장바구니 목록 만들기

> 1.  `cart`라는 이름의 빈 배열(아파트 건물)을 만드세요.
> 2.  `cart` 배열에 3개의 상품 \*\*객체(Object)\*\*를 순서대로 `push` 하세요. (아파트 1층, 2층, 3층 입주)
>       * 1층: { name: "휴지", price: 5000 }
>       * 2층: { name: "샴푸", price: 7000 }
>       * 3층: { name: "칫솔", price: 1500 }
>
> **미션:** `for`문을 사용하여 `cart` 배열을 순회하며 `price`가 6000원 미만인 상품의 `name`만 출력하세요.

### [실습 풀이]

```javascript
// 1. cart라는 이름의 빈 배열 만들기
let cart = [];

// 2. cart 배열에 3개의 상품 객체(Object)를 push
cart.push({ name: "휴지", price: 5000 }); // 0번 인덱스 (1층)
cart.push({ name: "샴푸", price: 7000 }); // 1번 인덱스 (2층)
cart.push({ name: "칫솔", price: 1500 }); // 2번 인덱스 (3층)

// --- 미션 수행 ---

// 1. for문을 사용하여 cart 배열 순회
for (let i = 0; i < cart.length; i++) {
  // cart[i]는 각 상품 객체를 의미합니다.
  // (예: i=0일 때 { name: "휴지", price: 5000 })

  // 2. 만약 상품의 price가 6000원 미만이라면
  if (cart[i].price < 6000) {
    // 그 상품의 name만 콘솔에 출력
    console.log(cart[i].name);
  }
}
// 출력 결과:
// 휴지
// 칫솔
```

-----

## 15\. [개념] String 객체의 내장 메서드 (length, trim, split)

`String`(문자열) 값은 자체적으로 유용한 기능(메서드)과 정보(속성)를 가지고 있습니다.

  * **`.length` (속성):**

      * 문자열의 \*\*총 길이(문자 개수)\*\*를 알려줍니다. (메서드가 아닌 **속성**이라 괄호 `()`가 없습니다.)
      * `"hello".length` -\> `5`
      * `" 안녕하세요 ".length` -\> `7` (공백 포함)

  * **`.trim()` (메서드):**

      * 문자열의 **앞과 뒤**에 있는 모든 **공백(스페이스, 탭, 줄바꿈)을 제거**한 *새로운* 문자열을 반환합니다.
      * `"   hello world   ".trim()` -\> `"hello world"` (중간 공백은 제거 안 됨)

  * **`.split(구분자)` (메서드):**

      * 문자열을 \*\*'구분자'\*\*를 기준으로 쪼개서 \*\*배열(Array)\*\*로 만들어 반환합니다.
      * `"a,b,c".split(",")` -\> `["a", "b", "c"]`
      * `"김밥/라면/쫄면".split("/")` -\> `["김밥", "라면", "쫄면"]`

-----

## 16\. [실습] 🧹 지저분한 이메일 목록 정리하기

> 시스템 오류로 이메일 목록이 한 줄의 문자열로, 심지어 앞뒤 공백까지 포함되어 저장되었습니다.
>
> `let dirtyEmails = "   kim@mail.com, lee@mail.com, park@mail.com   ";`
>
> **미션:** `trim()`으로 공백 제거, `split()`으로 배열 생성, `length`로 개수 확인, 첫 번째 이메일 출력

### [실습 풀이]

```javascript
let dirtyEmails = "   kim@mail.com, lee@mail.com, park@mail.com   ";

// 1. 앞뒤 공백 제거 (trim() 사용)
let cleanEmails = dirtyEmails.trim();
// cleanEmails = "kim@mail.com, lee@mail.com, park@mail.com"

// 2. 쉼표(,)와 공백(" ")을 기준으로 쪼개서 배열로 만듦 (split() 사용)
// (데이터가 ", "로 구분되어 있으므로 ", "를 구분자로 사용)
let emailArray = cleanEmails.split(", ");
// emailArray = ["kim@mail.com", "lee@mail.com", "park@mail.com"]

// 3. 배열에 총 몇 개의 이메일이 있는지 출력 (length 속성 사용)
console.log("총 이메일 개수:", emailArray.length); // 총 이메일 개수: 3

// 4. 배열의 첫 번째 이메일 출력
console.log("첫 번째 이메일:", emailArray[0]); // 첫 번째 이메일: kim@mail.com
```

-----

## 17\. [개념] javascript 배열의 다양한 기능 메서드

*(17번 문제가 `[실습]`으로 되어있으나, 18번이 실습인 것으로 보아 `[개념]` 설명으로 대체합니다.)*

배열(Array)은 데이터를 관리하기 위한 강력한 메서드(기능)들을 제공합니다.

  * **데이터 추가/삭제 (원본 배열 변경)**

      * **`.push(item)`**: 배열의 **맨 뒤**에 요소를 추가합니다.
      * **`.pop()`**: 배열의 **맨 뒤** 요소를 제거하고, 그 값을 반환합니다.
      * **`.unshift(item)`**: 배열의 **맨 앞**에 요소를 추가합니다.
      * **`.shift()`**: 배열의 **맨 앞** 요소를 제거하고, 그 값을 반환합니다.

  * **데이터 검색**

      * **`.indexOf(item)`**: `item`이 배열의 몇 번째 인덱스에 있는지 찾아 반환합니다. (없으면 `-1`)
      * **`.includes(item)`**: `item`이 배열에 포함되어 있는지 `true` / `false`로 반환합니다.

  * **데이터 변형 (새로운 배열 반환)**

      * **`.map(function)`**: 배열의 모든 요소를 순회하며 함수를 적용한 **새로운 배열**을 반환합니다. (예: 모든 점수 2배)
      * **`.filter(function)`**: 함수 조건이 `true`인 요소들만 모아서 **새로운 배열**을 반환합니다. (예: 90점 이상인 학생만)

-----

## 18\. [실습] 🎶 플레이리스트 관리하기

> 1.  `playlist`라는 이름의 배열을 만들고, 초기 곡으로 `"아이유-밤편지"`, `"BTS-다이너마이트"`를 넣어주세요.
>
> **미션:**
>
> 1.  **`.push()`**: 플레이리스트의 **맨 뒤에** `"블랙핑크-마지막처럼"`을 추가하고, `playlist` 전체를 출력하세요.
> 2.  **`.pop()`**: 플레이리스트의 **맨 뒤** 곡을 제거하고, `playlist` 전체를 출력하세요.

### [실습 풀이]

```javascript
// 1. playlist 배열 초기화
let playlist = ["아이유-밤편지", "BTS-다이너마이트"];
console.log("초기 플레이리스트:", playlist);

// --- 미션 1: .push() ---
console.log("--- push 수행 ---");
playlist.push("블랙핑크-마지막처럼");
console.log("push 후:", playlist);
// (출력: ["아이유-밤편지", "BTS-다이너마이트", "블랙핑크-마지막처럼"])

// --- 미션 2: .pop() ---
console.log("--- pop 수행 ---");
let removedSong = playlist.pop(); // "블랙핑크-마지막처럼"이 제거됨
console.log("pop으로 제거된 곡:", removedSong);
console.log("pop 후:", playlist);
// (출력: ["아이유-밤편지", "BTS-다이너마이트"])
```